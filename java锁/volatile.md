###  volatile定义

#####  Java语言规范第3版中对volatile的定义如下：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。

volatile是如何来保证可见性的呢？让我们在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时，CPU会做什么事情。
Java代码如下。

```  
instance = new Singleton(); // instance是volatile变量
```

转变成汇编代码，如下。

``` 
0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp);
```



有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情[1]。

**1）将当前处理器缓存行的数据写回到系统内存。
2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。**

下面来具体讲解volatile的两条实现原则。
1）Lock前缀指令会引起处理器缓存回写到内存。Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存[2]。但是，在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。在8.1.4节有详细说明锁定操作对处理器缓存的影响，对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，**并使用缓存一致性机制来确保修改的原子性**，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。
2）一个处理器的缓存回写到内存会导致其他处理器的缓存无效。IA-32处理器和Intel 64处理器使用MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。例如，在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。

#### 特性

![1573400319167](C:\Users\czd\AppData\Roaming\Typora\typora-user-images\1573400319167.png)

![1573400333367](C:\Users\czd\AppData\Roaming\Typora\typora-user-images\1573400333367.png)

#### 总结

1. 对单个volatile变量的读写，可以看作使用同一个锁去做同步。CAS也是通过操作volatile的变量和cas原子指令来完成。

2. 对volatile变量的写，happens-before 后面对该变量的读，并且禁止与后面的volatile读写重排序

   ![1573567111700](C:\Users\czd\AppData\Roaming\Typora\typora-user-images\1573567111700.png)

3. 对volatile变量的读，happens-before与对volatile变量的读写，并且禁止与普通的读写重排序

![1573567096170](C:\Users\czd\AppData\Roaming\Typora\typora-user-images\1573567096170.png)

![1574041080914](C:\Users\czd\AppData\Roaming\Typora\typora-user-images\1574041080914.png)

