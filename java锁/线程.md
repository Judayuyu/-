#### 过期的方法

![1573570792427](D:\笔记\面试题\java锁\assets\1573570792427.png)

![1573570805821](D:\笔记\面试题\java锁\assets\1573570805821.png)

#### 等待通知机制

**注意： 无论是notify() 还是wait()方法，都必须在获取对象锁的前提上调用**

**notify()方法不会引发异常**

#####    1. object中的方法

![1573614482785](D:\笔记\面试题\java锁\assets\1573614482785.png)

##### 2. Thread . join()源码

```java
  public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                //此时若等待的线程已经结束，会调用notifyAll()方法唤醒该线程
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
```

![1573704404503](D:\笔记\面试题\java锁\assets\1573704404503.png)

#### ThreadLocal

![1573741219558](D:\笔记\面试题\java锁\assets\1573741219558.png)

1. 提供线程级别的变量

2. ThreadLocal维护一个ThreadLocalMap，map的key为ThreadLocal，value为Object 。

3. 同一个线程下，多个ThreadLocal实例都是访问同个map，**其原理是通过当前线程获取map**，然后该ThreadLocal的实例作为key，去获取map中的值。

   

   初始化代码如下：t变量是当前线程

   ThreadLocalMap是ThreadLocal的静态内部类，里面维护一个Entry数组，与hashmap类似

   ##### set() 和 get() 方法

   ```java
    public void set(T value) {
           Thread t = Thread.currentThread();
           ThreadLocalMap map = getMap(t);
           if (map != null) {
               map.set(this, value);
           } else {
               createMap(t, value);
           }
       }
   
   void createMap(Thread t, T firstValue) {
       t.threadLocals = new ThreadLocalMap(this, firstValue);
   }
   
     private void set(ThreadLocal<?> key, Object value) {
   
               // We don't use a fast path as with get() because it is at
               // least as common to use set() to create new entries as
               // it is to replace existing ones, in which case, a fast
               // path would fail more often than not.
   
               Entry[] tab = table;
               int len = tab.length;
               int i = key.threadLocalHashCode & (len-1);
   
               for (Entry e = tab[i];
                    e != null;
                    e = tab[i = nextIndex(i, len)]) {
                   ThreadLocal<?> k = e.get();
   
                   if (k == key) {
                       e.value = value;
                       return;
                   }
   
                   if (k == null) {
                       replaceStaleEntry(key, value, i);
                       return;
                   }
               }
   
               tab[i] = new Entry(key, value);
               int sz = ++size;
               if (!cleanSomeSlots(i, sz) && sz >= threshold)
                   rehash();
           }
   
   ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
       table = new Entry[INITIAL_CAPACITY];
       int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
       table[i] = new Entry(firstKey, firstValue);
       size = 1;
       setThreshold(INITIAL_CAPACITY);
   }
   
   public T get() {
       Thread t = Thread.currentThread();
       ThreadLocalMap map = getMap(t);
       if (map != null) {
           ThreadLocalMap.Entry e = map.getEntry(this);
           if (e != null) {
               @SuppressWarnings("unchecked")
               T result = (T)e.value;
               return result;
           }
       }
       return setInitialValue();
   }
   
     private Entry getEntry(ThreadLocal<?> key) {
               int i = key.threadLocalHashCode & (table.length - 1);
               Entry e = table[i];
               if (e != null && e.get() == key)
                   return e;
               else
                   return getEntryAfterMiss(key, i, e);
           }
   ```

   


